---
title: "Syntax"
description: "How to write aether code"
---

# Syntax

Sometimes, when you read documentation, you have to read a lot of pages to truly understand the language. On this page is every single kind of syntax in the std library.

This is however, by no means a good description of the language's syntax. If you want to learn more about each keyword, you can read the individual pages following this one.

## For

The `for` keyword is used to tell aether what elements to target.

```aether
for @item {
    <YOUR CODE HERE>
}
```

Essentially, this keyword is used to tell aether what to style. The methodology for it is as follows:

You use `for` to tell aether "This is what I want to style".

### Selectors

Selectors are the way to target and style elements in aether. Below are the currently supported selectors:

- **Element Selectors** - Used to target elements based on their class name.
- **Individual Selectors** - Used to target elements based on their individual identifier.

#### Element Selectors

You use the `@` symbol to tell aether what you want to style. The `@` symbol is used to denote a class name. So, for example, if you wanted to style all elements with the class `item`, you would use the following code:

```aether
for @item {
    <YOUR CODE HERE>
}
```

In this example, `@item` is the selector that tells aether to target all elements with the class `item`.

#### Individual element Selectors

You can also use the `#` symbol to denote a specific element. For example, if you wanted to style a specific element with the id `item`, you would use the following code:

```aether
for #item {
    <YOUR CODE HERE>
}
```

In this example, `#item` is the selector that tells aether to target the element with the identifier `item`.

## Dec

The `dec` keyword is used **to declare a style property.** There are two ways that it can be written:

`dec` followed by a style property name

or

`declare` followed by a style property name (more on this later)

### Style Property Names

<Tip>
  You can use all of the available styling options in css with the std library.
  (Excludes flex and grid)
</Tip>

Style property names are the names of the properties that you want to style. **They are the names of the CSS properties that you want to style.** For example, if you wanted to style the background color of an element, you would use the following: `dec bgColor`.

The compiler can understand the following style property name syntaxes:

`bgColor` - This is the camel case version of the style property name. It is the most common way to write style property names.

`bgcolor` - This is the lowercase version of the style property name. It is the second most common way to write style property names.

`background-color` - This is the kebab case version of the style property name. It is the third most common way to write style property names.

`BackgroundColor` - This is the pascal case version of the style property name. It is the fourth most common way to write style property names.

Of coure, you can use any of the above syntaxes, but what if you want a custom name? Thats where the next keyword comes in.

## As

The `as` keyword is used to tell aether what the style property should be referred to as. For example, if you wanted to style the background color of an element, you would use the following:

```aether
dec bgColor as background-color;
```

In this example, `background-color` is the style property that you want to style. The `as` keyword is used to tell aether what the style property should be referred to as. Here's another example:

```aether
dec bgColor as darkModeColor;
```

In this example, `bgColor` is the style property that you want to style. The `as` keyword is used to tell aether what the style property should be referred to as. In this case, `darkModeColor`.

<Tip>
  You can use the `as` keyword to tell aether what the style property should be
  referred to as. This is useful if you want to use a custom name for the style
  property.{" "}
</Tip>

## Scope

While the `scope` isn't an actual keyword, it is helpful to know how aether scopes variables.

### Global vs. Local Scope

Scope in aether is the same as scope in any other programming language. There are two types of scope: global and local.

#### Global Scope

Global scope means that it is available to everything in the file. For example, I can declare a variable like a default background color, and make it global. There are multiple ways to do this.

#### Method 1. Using the `global` keyword

```aether
for @item {
    dec global bgColor as defaultBGColor with value #000000;
}
```

This introduces a lot of compilcation, so let's break it down.

First, we declare the variable using the `dec` keyword. This tells aether that we are declaring a variable.

Then we use the `global` keyword. This tells aether that we want to declare a global variable.

Then we use the `as` keyword. This tells aether that we want it to be called `defaultBGColor`.

Here's the new portion: `with value #000000;`. This tells aether that we want to set the value of the variable to `#000000`. The reason we do it like this is because when declaring a global variable, it is immutable by default after initalization. So, we have to set the value of the variable when we declare it.

#### Immuatbality?

Essentially, immutability means that the variable cannot be changed after it is declared. This is useful for global variables because it prevents them from being changed by accident. Of course, they can be changed locally, i.e. within a `for` block. But, they cannot be changed globally. This allows for more internal customiazation of the variable, white still preserving the global value.

#### Method 2. Declaring the variable outside of a `for` block

While it is technically possible to declare a global variable using method 1, it is not the best way to do it. It is better to declare the variable outside of a `for` block. This is because it allows for more internal customiazation of the variable, while still preserving the global value.

```aether
dec global bgColor as defaultBGColor with value #000000;
```

This is the same as method 1, but it is declared outside of a `for` block.

### Local Scope

Local scope means that it is only available to the `for` block that it is declared in. For example, I can declare a variable like a default background color inside of a `for` block to make it local.
This means that it is only available to the `for` block that it is declared in.

#### Local to Global variables

Local variables can be _very_ useful at times. But what if you want to provide the file or other files with the value? You can't do it with global variables due to immutability. But, you can do it with local variables.

#### The `export` method

You can use the `export` keyword to export a local variable to a global scope, i.e. the file. But you can also use the `export` keyword to export a local variable to different files, or use it as an aether environment variable. The syntax is as follows:

```aether
for @item {
    dec bgColor as defaultBGColor with value #000000;
    export bgColor;
}
```

In this example, `defaultBGColor` is the local variable that we want to export. The `export` keyword is used to tell aether that we want to export the variable. This allows us to use the variable in other files, or as an aether environment variable.

#### The `import` method

What if you want to use a variable from another file? You can use the `import` keyword to import a variable from another file. The syntax is as follows:

```aether
import defaultBGColor from "./file.aether";
```

In this example, `defaultBGColor` is the variable that we want to import. The `import` keyword is used to tell aether that we want to import the variable. This allows us to use the variable in other files, or as an aether environment variable.

### Environment variables?

Environment variables are variables that can be used in any file. They are defined in the `rules.config.aether` file. The syntax is as follows:

```aether
import config from "aetherConfig";

for * {
    dec bgColor as defaultBGColor with value "#000000";
}

<REST OF YOUR CONFIG HERE>
```

This is a simple example of how to declare an environment variable, notice that we are using the `*` selector on our `for` block. This tells aether that we want to give this variable to all elements.

<Tip>
  You don't actually need an `export` keyword to export a environment variable.
  It is automatically exported since your using the `*` selector.
</Tip>

But how do you write an aether config file?

## Aether Config File

The aether config file is a file that is used to configure aether. It is used to set up the environment variables, and to set up the default values for the variables. There are numerous ways to write a config file. You can explore all possible options on the individual config page later on, but here is a quick run down.

<Tip>Your config file should be named `rules.config.aether`</Tip>

### Syntax

The syntax for a basic config file with an environment variable is as follows:

```aether
import config from "aetherConfig";

for * {
    dec bgColor as defaultBGColor with value "#000000";
}
```

#### What is the `config` import?

The `config` import is a part of the std library, that isn't bundled in production builds. It essentially just tells aether how you want the compiler to work, and if you want any global variables.

#### The config object

The config object is an object that is used to configure the aether compiler, and how the language functions in your project. Below are a few options, and an example of the object.

```aether
import config from "aetherConfig";
config {
    minify: true;
    typesafety: true;
    globalVariables: true;
}
```

#### The `minify` option

The `minify` option is used to tell aether whether or not to minify the compiled code. This is useful for production builds, but can also be useful for development builds. The default value is `false`.

#### The `typesafety` option

The `typesafety` option is used to tell aether whether or not to enable typesafety. This is useful for development builds, but can also be useful for production builds. The default value is `false`.

#### The `globalVariables` option

The `globalVariables` option is used to tell aether whether or not to enable global variables. This is useful for development builds, but can also be useful for production builds. The default value is `false`.

### Adding functionality

<Warning>
  Everything Below this point, is not immediately available like in other
  languages. You have to import the functionality from the std library.
</Warning>

Aether is designed to be small, powerful, extensible, modular, and fast. So some things you would find in a "functional" programming language are imports. You can have them in every file using the `rules.config.aether` file, or import them as needed.

#### Typing

<Note>
  Typing is required to be in all files if enabled in the config file. You
  cannot use it in a file without typing enabled, or on a case by case basis.
</Note>

Typing is a powerful feature of aether. It allows you to define the types of variables, and to define the types of functions. **It must be enabled in the config file to work.** The syntax is as follows:

```aether
import config from "aetherConfig";
config {
    typesafety: true;
}
```

In this example, we are enabling typesafety in the config file. Now, we can define the types of variables and functions.

#### Built in types

When you enable typesafety, you can use the following built in types:

- `string` - A string is a sequence of characters. It is used to represent text.
- `number` - A number is a numeric value. It is used to represent numbers.
- `boolean` - A boolean is a true or false value. It is used to represent true or false values.
- `array` - An array is a list of values. It is used to represent a list of values.
- `object` - An object is a collection of key value pairs. It is used to represent a collection of values.
- `function` - A function is a block of code that can be called. It is used to represent a block of code that can be called.
- `any` - The any type is a special type that can be used to represent any type. It is used to represent any type of value.
- `void` - The void type is a special type that can be used to represent a function that does not return a value. It is used to represent a function that does not return a value.

The above types are standard types with functional programming languages. But, aether also has some custom types. These are types that are specific to aether that can be used to make styling easier. They are as follows:

#### Built in custom styling types

- `color` – A color value that defines how something is displayed visually. It can be represented in different formats:

  - `hex` – A hexadecimal color code, e.g., `#ff5733`.
  - `rgb` – Red, Green, Blue color model, e.g., `rgb(255, 87, 51)`.
  - `rgba` – RGB with Alpha (opacity), e.g., `rgba(255, 87, 51, 0.5)`.
  - `hsl` – Hue, Saturation, Lightness model, e.g., `hsl(9, 100%, 60%)`.
  - `hsla` – HSL with Alpha, e.g., `hsla(9, 100%, 60%, 0.5)`.
  - `hwb` – Hue, Whiteness, Blackness model, e.g., `hwb(9 0% 0%)`.
  - `lab` – CIE Lab color space, used for more accurate color representation, e.g., `lab(54.29% 80.82 69.88)`.
  - `lch` – Lightness, Chroma, Hue format, e.g., `lch(54.29% 104.55 40.85)`.
  - `named color` – Predefined color names like `red`, `blue`, `rebeccapurple`, etc.

- `position` – Specifies how an element is positioned in a document. Common values include:
  - `static` – Default positioning; elements follow the normal document flow.
  - `relative` – Positioned relative to its normal position; offsets can adjust its placement.
  - `absolute` – Positioned relative to the nearest positioned ancestor; removed from normal flow.
  - `fixed` – Positioned relative to the viewport; remains in place during scrolling.
  - `sticky` – Switches between relative and fixed, depending on scroll position.

**More will be added in the future.**

#### Custom types

You can also define your own custom types. This is useful if you want to define a custom type that is specific to your project. The syntax is as follows:

```aether
import config from "aetherConfig";
config {
    typesafety: true;
}

type MyCustomType {
    property1: string;
    property2: number;
}
```

In this example, we are defining a custom type called `MyCustomType`. This type has two properties: `property1` and `property2`. These properties are both strings and numbers, respectively.

#### Functions

Functions are a powerful feature of aether. They allow you to define a block of code that can be called. The syntax is as follows:

```aether
import config from "aetherConfig";
config {
    typesafety: true;
}

function myFunction() {
    return "Hello, world!";
}
```

In this example, we are defining a function called `myFunction`. This function returns the string `"Hello, world!"`. We can call this function using the following syntax:

```aether
myFunction();
```

In this example, we are calling the function `myFunction`. This will return the string `"Hello, world!"`.

#### Function parameters

Functions can also take parameters. This is useful if you want to pass values to the function. The syntax is as follows:

```aether
import config from "aetherConfig";
config {
    typesafety: true;
}

function myFunction(param1: string, param2: number) {
    return param1 + param2;
}
```

In this example, we are defining a function called `myFunction`. This function takes two parameters: `param1` and `param2`. These parameters are both strings and numbers, respectively. The function returns the sum of the two parameters.

#### Function return type

Functions can also have a return type. This is useful if you want to specify the type of value that the function returns. The syntax is as follows:

```aether
import config from "aetherConfig";
config {
    typesafety: true;
}

function myFunction(param1: string, param2: number): string {
    return param1 + param2;
}
```

In this example, we are defining a function called `myFunction`. This function takes two parameters: `param1` and `param2`. These parameters are both strings and numbers, respectively. The function returns a string.

#### Functions as values

You can also use functions as values. This is useful if you want to use a function as a value. The syntax is as follows:

```aether
import config from "aetherConfig";
config {
    typesafety: true;
}

function myFunction(param1: string, param2: number): string {
    return param1 + param2;
}

let myFunctionValue = myFunction();
```

In this example, we are defining a function called `myFunction`. This function takes two parameters: `param1` and `param2`. These parameters are both strings and numbers, respectively. The function returns a string. We are then declaring a variable called `myFunctionValue` and assigning it the value of the function `myFunction`.

#### Conditionals

Conditionals, function similarly to conditionals in other programming languages. They are used to execute a block of code based on a condition. The syntax is as follows:

```aether
function myFunction(param1: string, param2: number): string {
    if (param1 === "hello") {
        return "Hello, world!";
    } else {
        return "Goodbye, world!";
    }
}

myFunction("hello", 123);
```

In this example, we are defining a function called `myFunction`. This function takes two parameters: `param1` and `param2`. These parameters are both strings and numbers, respectively. The function returns a string. We are then declaring a variable called `myFunctionValue` and assigning it the value of the function `myFunction`.

#### Loops

Loops are used to execute a block of code multiple times. The syntax is as follows:

```aether
repeat (var i = 0; i < 10; i++) {
    console.log(i);
}
```

Notice anything different? Aether has multiple variable declaration methods. `var` is exclusive to loops, and is used to declare a variable that is only available in the loop.
